#include "common_layers.h"
#include "model.h"
#include <cmath>
#include <iostream>
#include "conv.h"

using namespace std;

// ---------------------------------------------
// Conv layer generated by the code generator
// ---------------------------------------------
/*Symbol*/
void conv_hcl(bit input[MAX_FMAP], const bit W_conv[MAX_W_CONV], const bit8_t threshold[MAX_FMAP], bit Result[MAX_FMAP]) {
   ap_uint<8> PackedTensor[324];
  for (int xx = 0; xx < 18; ++xx) {
    for (int yy = 0; yy < 18; ++yy) {
       bit ExtractedVector;
      ExtractedVector = input[((yy + (xx * 18)) + (0 * 324))];
       ap_uint<8> PackedNumber;
       bit local0;
      local0 = (ap_uint<1>)0;
      local0 = ExtractedVector;
      PackedNumber = local0;
      PackedTensor[((yy + (xx * 18)) + (0 * 324))] = PackedNumber;
    }
  }
  for (int cc = 0; cc < 16; ++cc) {
#pragma HLS pipeline
    for (int xx1 = 0; xx1 < 16; ++xx1) {
      for (int yy1 = 0; yy1 < 16; ++yy1) {
         bit Window[9];
        for (int x = 0; x < 3; ++x) {
          for (int y = 0; y < 3; ++y) {
            Window[((y + (x * 3)) + (0 * 9))] = PackedTensor[(((((ap_int<34>)yy1) + ((ap_int<34>)y)) + ((((ap_int<34>)xx1) + ((ap_int<34>)x)) * (ap_int<34>)18)) + ((ap_int<34>)(0 * 324)))];
          }
        }
         bit ExtractedFilter[9];
        for (int xx2 = 0; xx2 < 3; ++xx2) {
          for (int yy2 = 0; yy2 < 3; ++yy2) {
            ExtractedFilter[((yy2 + (xx2 * 3)) + (0 * 9))] = W_conv[(((yy2 + (xx2 * 3)) + (0 * 9)) + (cc * 9))];
          }
        }
         ap_uint<8> PackedTensor1[9];
        for (int xx3 = 0; xx3 < 3; ++xx3) {
          for (int yy3 = 0; yy3 < 3; ++yy3) {
             bit ExtractedVector1;
            ExtractedVector1 = ExtractedFilter[((yy3 + (xx3 * 3)) + (0 * 9))];
             ap_uint<8> PackedNumber1;
             ap_uint<8> local1;
            local1 = (ap_uint<1>)0;
            local1 = ExtractedVector1;
            PackedNumber1 = local1;
            PackedTensor1[((yy3 + (xx3 * 3)) + (0 * 9))] = PackedNumber1;
          }
        }
         bit BitwiseAnd[9];
        for (int xx4 = 0; xx4 < 3; ++xx4) {
          for (int yy4 = 0; yy4 < 3; ++yy4) {
            BitwiseAnd[((yy4 + (xx4 * 3)) + (0 * 9))] = (Window[((yy4 + (xx4 * 3)) + (0 * 9))] & PackedTensor1[((yy4 + (xx4 * 3)) + (0 * 9))]);
          }
        }
         unsigned int PopCNT[9];
        for (int x1 = 0; x1 < 3; ++x1) {
          for (int y1 = 0; y1 < 3; ++y1) {
             unsigned int local2;
            local2 = 0U;
            local2 = ((unsigned int)(((ap_uint<33>)local2) + ((ap_uint<33>)((BitwiseAnd[((y1 + (x1 * 3)) + (0 * 9))] & (1L << 0)) >> 0))));
            PopCNT[((y1 + (x1 * 3)) + (0 * 9))] = local2;
          }
        }
         unsigned int SumUp;
         int reducer0;
        reducer0 = 0;
        for (int ra = 0; ra < 3; ++ra) {
          for (int ra1 = 0; ra1 < 3; ++ra1) {
            reducer0 = ((int)(((ap_int<34>)PopCNT[(((((ap_int<34>)0) + ((ap_int<34>)ra1)) + ((((ap_int<34>)0) + ((ap_int<34>)ra)) * (ap_int<34>)3)) + ((((ap_int<34>)0) + ((ap_int<34>)0)) * (ap_int<34>)9))]) + ((ap_int<34>)reducer0)));
          }
        }
        SumUp = ((unsigned int)reducer0);
        Result[((yy1 + (xx1 * 16)) + (cc * 256))] = ((ap_uint<1>)((((int)threshold[((yy1 + (xx1 * 16)) + (cc * 256))]) < ((int)SumUp)) ? 1 : 0));
      }
    }
  }
}



/*Symbol2*/
void conv_hcl2(bit input[MAX_FMAP], const bit W_conv[MAX_W_CONV], const bit8_t threshold[MAX_FMAP], bit Result[MAX_FMAP]) {
   ap_uint<16> PackedTensor[100];
  for (int xx = 0; xx < 10; ++xx) {
    for (int yy = 0; yy < 10; ++yy) {
       bit ExtractedVector[16];
      for (int x = 0; x < 16; ++x) {
        (( ap_uint<1>*)ExtractedVector)[x] = input[((yy + (xx * 10)) + (x * 100))];
      }
       ap_uint<16> PackedNumber;
       ap_uint<16> local3;
      local3 = (ap_uint<16>)0;
      for (int i = 0; i < 16; ++i) {
        local3((i ), i) = ExtractedVector[(ap_uint<34>((0)) + ap_uint<34>(i))];
      }
      PackedNumber = local3;
      PackedTensor[((yy + (xx * 10)) + (0 * 100))] = PackedNumber;
    }
  }
  for (int cc = 0; cc < 32; ++cc) {
#pragma HLS pipeline
    for (int xx1 = 0; xx1 < 8; ++xx1) {
      for (int yy1 = 0; yy1 < 8; ++yy1) {
         ap_uint<16> Window[9];
        for (int x1 = 0; x1 < 3; ++x1) {
          for (int y = 0; y < 3; ++y) {
            Window[((y + (x1 * 3)) + (0 * 9))] = PackedTensor[(((((ap_int<34>)yy1) + ((ap_int<34>)y)) + ((((ap_int<34>)xx1) + ((ap_int<34>)x1)) * (ap_int<34>)10)) + ((ap_int<34>)(0 * 100)))];
          }
        }
         ap_uint<8> ExtractedFilter[144];
        for (int zz = 0; zz < 16; ++zz) {
          for (int xx2 = 0; xx2 < 3; ++xx2) {
            for (int yy2 = 0; yy2 < 3; ++yy2) {
              ExtractedFilter[((yy2 + (xx2 * 3)) + (zz * 9))] = W_conv[(((yy2 + (xx2 * 3)) + (zz * 9)) + (cc * 144))];
            }
          }
        }
         ap_uint<16> PackedTensor1[9];
        for (int xx3 = 0; xx3 < 3; ++xx3) {
          for (int yy3 = 0; yy3 < 3; ++yy3) {
             bit ExtractedVector1[16];
            for (int x2 = 0; x2 < 16; ++x2) {
              (( ap_uint<1>*)ExtractedVector1)[x2] = ExtractedFilter[((yy3 + (xx3 * 3)) + (x2 * 9))];
            }
             ap_uint<16> PackedNumber1;
             ap_uint<16> local4;
            local4 = (ap_uint<16>)0;
            for (int i1 = 0; i1 < 16; ++i1) {
              local4((i1 ), i1) = ExtractedVector1[(ap_uint<34>((0)) + ap_uint<34>(i1))];
            }
            PackedNumber1 = local4;
            PackedTensor1[((yy3 + (xx3 * 3)) + (0 * 9))] = PackedNumber1;
          }
        }
         ap_uint<16> BitwiseAnd[9];
        for (int xx4 = 0; xx4 < 3; ++xx4) {
          for (int yy4 = 0; yy4 < 3; ++yy4) {
            BitwiseAnd[((yy4 + (xx4 * 3)) + (0 * 9))] = (Window[((yy4 + (xx4 * 3)) + (0 * 9))] & PackedTensor1[((yy4 + (xx4 * 3)) + (0 * 9))]);
          }
        }
         unsigned int PopCNT[9];
        for (int x3 = 0; x3 < 3; ++x3) {
          for (int y1 = 0; y1 < 3; ++y1) {
             unsigned int local5;
            local5 = 0U;
            for (int i2 = 0; i2 < 16; ++i2) {
              local5 = ((unsigned int)(((ap_uint<33>)local5) + ((ap_uint<33>)((BitwiseAnd[((y1 + (x3 * 3)) + (0 * 9))] & (1L << i2)) >> i2))));
            }
            PopCNT[((y1 + (x3 * 3)) + (0 * 9))] = local5;
          }
        }
         unsigned int SumUp;
         int reducer1;
        reducer1 = 0;
        for (int ra = 0; ra < 3; ++ra) {
          for (int ra1 = 0; ra1 < 3; ++ra1) {
            reducer1 = ((int)(((ap_int<34>)PopCNT[(((((ap_int<34>)0) + ((ap_int<34>)ra1)) + ((((ap_int<34>)0) + ((ap_int<34>)ra)) * (ap_int<34>)3)) + ((((ap_int<34>)0) + ((ap_int<34>)0)) * (ap_int<34>)9))]) + ((ap_int<34>)reducer1)));
          }
        }
        SumUp = ((unsigned int)reducer1);
        Result[((yy1 + (xx1 * 8)) + (cc * 64))] = ((ap_uint<1>)((((int)threshold[((yy1 + (xx1 * 8)) + (cc * 64))]) < ((int)SumUp)) ? 1 : 0));
      }
    }
  }
}

